const form        = document.getElementById("kycForm");
const statusBox   = document.getElementById("status");
const previewVideo = document.getElementById("preview");

let stream;

// Start camera
async function startCamera() {
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    previewVideo.srcObject = stream;
    previewVideo.style.display = "block";
  } catch (err) {
    console.error(err);
    statusBox.textContent = "Camera/Microphone access denied.";
    throw err;
  }
}

// Record 8-second video
async function recordVideo() {
  return new Promise(async (resolve) => {
    const mediaRecorder = new MediaRecorder(stream);
    const chunks = [];

    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
    mediaRecorder.onstop = () => {
      const videoFile = new Blob(chunks, { type: "video/webm" });
      resolve(videoFile);
    };

    mediaRecorder.start();
    await new Promise(r => setTimeout(r, 8000)); // 8 seconds
    mediaRecorder.stop();
  });
}

// Upload form + video
async function uploadData(formData, videoFile) {
  formData.append("video", videoFile, "verification.webm");

  const res = await fetch("/upload", {
    method: "POST",
    body: formData
  });

  if (!res.ok) {
    throw new Error("Upload failed: " + res.status);
  }

  return res.text();
}

// Handle form submission
if (form) {
  form.addEventListener("submit", async (event) => {
    event.preventDefault();

    try {
      statusBox.textContent = "Starting camera…";
      await startCamera();

      statusBox.textContent = "Recording video…";
      const videoFile = await recordVideo();

      statusBox.textContent = "Uploading…";
      const formData = new FormData(form);
      const result = await uploadData(formData, videoFile);

      statusBox.textContent = "Submitted! Server says: " + result;
    } catch (err) {
      console.error(err);
      statusBox.textContent = "Error: " + (err.message || err);
    } finally {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
      }
    }
  });
}
